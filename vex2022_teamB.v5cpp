{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor leftMotorA = motor(PORT14, ratio18_1, false);\nmotor leftMotorB = motor(PORT18, ratio18_1, false);\nmotor_group LeftDriveSmart = motor_group(leftMotorA, leftMotorB);\nmotor rightMotorA = motor(PORT17, ratio18_1, true);\nmotor rightMotorB = motor(PORT19, ratio18_1, true);\nmotor_group RightDriveSmart = motor_group(rightMotorA, rightMotorB);\ndrivetrain Drivetrain = drivetrain(LeftDriveSmart, RightDriveSmart, 319.19, 295, 40, mm, 1);\n\nmotor mobileGoalIntakeMotorA = motor(PORT15, ratio36_1, false);\nmotor mobileGoalIntakeMotorB = motor(PORT16, ratio36_1, true);\nmotor_group mobileGoalIntake = motor_group(mobileGoalIntakeMotorA, mobileGoalIntakeMotorB);\n\nmotor rollers = motor(PORT20, ratio18_1, false);\n\ncontroller Controller1 = controller(primary);\ninertial Inertial12 = inertial(PORT12);\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n// define variables used for controlling motors based on controller inputs\nbool DrivetrainLNeedsToBeStopped_Controller1 = true;\nbool DrivetrainRNeedsToBeStopped_Controller1 = true;\n\n// define a task that will handle monitoring inputs from Controller1\nint rc_auto_loop_function_Controller1() {\n  // process the controller input every 20 milliseconds\n  // update the motors based on the input values\n  while(true) {\n    if(RemoteControlCodeEnabled) {\n      // calculate the drivetrain motor velocities from the controller joystick axies\n      // left = Axis3 + Axis1\n      // right = Axis3 - Axis1\n      int drivetrainLeftSideSpeed = Controller1.Axis3.position() + Controller1.Axis1.position();\n      int drivetrainRightSideSpeed = Controller1.Axis3.position() - Controller1.Axis1.position();\n      \n      // check if the value is inside of the deadband range\n      if (drivetrainLeftSideSpeed < 5 && drivetrainLeftSideSpeed > -5) {\n        // check if the left motor has already been stopped\n        if (DrivetrainLNeedsToBeStopped_Controller1) {\n          // stop the left drive motor\n          LeftDriveSmart.stop();\n          // tell the code that the left motor has been stopped\n          DrivetrainLNeedsToBeStopped_Controller1 = false;\n        }\n      } else {\n        // reset the toggle so that the deadband code knows to stop the left motor nexttime the input is in the deadband range\n        DrivetrainLNeedsToBeStopped_Controller1 = true;\n      }\n      // check if the value is inside of the deadband range\n      if (drivetrainRightSideSpeed < 5 && drivetrainRightSideSpeed > -5) {\n        // check if the right motor has already been stopped\n        if (DrivetrainRNeedsToBeStopped_Controller1) {\n          // stop the right drive motor\n          RightDriveSmart.stop();\n          // tell the code that the right motor has been stopped\n          DrivetrainRNeedsToBeStopped_Controller1 = false;\n        }\n      } else {\n        // reset the toggle so that the deadband code knows to stop the right motor next time the input is in the deadband range\n        DrivetrainRNeedsToBeStopped_Controller1 = true;\n      }\n      \n      // only tell the left drive motor to spin if the values are not in the deadband range\n      if (DrivetrainLNeedsToBeStopped_Controller1) {\n        LeftDriveSmart.setVelocity(drivetrainLeftSideSpeed, percent);\n        LeftDriveSmart.spin(forward);\n      }\n      // only tell the right drive motor to spin if the values are not in the deadband range\n      if (DrivetrainRNeedsToBeStopped_Controller1) {\n        RightDriveSmart.setVelocity(drivetrainRightSideSpeed, percent);\n        RightDriveSmart.spin(forward);\n      }\n    }\n    // wait before repeating the process\n    wait(20, msec);\n  }\n  return 0;\n}\n\ntask rc_auto_loop_task_Controller1(rc_auto_loop_function_Controller1);\n\n\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// Include the V5 Library\n// Skill auton code\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\ncompetition Competition;\n\nfloat rollersDirection;\n\nbool lifted;\n\nevent message1 = event();\nfloat kp = 0.065;\nfloat ki = 0.006;\nfloat kd = 0.000;\n\nvoid pid_turn_right_by(float angle, float expected_angle) {\n    float error = 0.5;\n    float delay = 0.01; // 10 milliseconds\n    float integral = 0;\n    float prev_error = 0;\n    float derivation = 0;\n    float power = 0;\n    Drivetrain.setStopping(brake);\n    float cur_angle = Inertial12.rotation(degrees);\n    float final_angle = cur_angle + angle;\n    printf(\"Angle = %.2f, error = %.2f, final = %.2f\\n\", cur_angle, (cur_angle - expected_angle), final_angle);\n    error = final_angle - Inertial12.rotation();\n    while(error > 0.2) {\n      integral += error * delay;\n      derivation = (error - prev_error) / delay;\n      power = kp * error + ki * integral + kd * derivation;\n      if (power < 1.5) {\n        power = 1.5;\n      }\n      RightDriveSmart.spin(reverse, power, volt);\n      LeftDriveSmart.spin(forward, power, volt);\n      wait(delay,seconds);\n      error = final_angle - Inertial12.rotation();\n    }\n    Drivetrain.stop();\n    printf(\"stopped angle = %.2f\\n\", Inertial12.rotation());\n}\n\nvoid pid_turn_right_to(float angle) {\n    float error = 0.5;\n    float delay = 0.01; // 10 milliseconds\n    float integral = 0;\n    float prev_error = 0;\n    float derivation = 0;\n    float power = 0;\n    Drivetrain.setStopping(brake);\n    float cur_angle = Inertial12.rotation(degrees);\n    float final_angle = angle;\n    printf(\"Angle = %.2f, final = %.2f\\n\", cur_angle, final_angle);\n    error = final_angle - Inertial12.rotation();\n    while(error > 0.2) {\n      integral += error * delay;\n      derivation = (error - prev_error) / delay;\n      power = kp * error + ki * integral + kd * derivation;\n      if (power < 1.5) {\n        power = 1.5;\n      }\n      RightDriveSmart.spin(reverse, power, volt);\n      LeftDriveSmart.spin(forward, power, volt);\n      wait(delay,seconds);\n      error = final_angle - Inertial12.rotation();\n    }\n    Drivetrain.stop();\n    printf(\"stopped angle = %.2f\\n\", Inertial12.rotation());\n}\n\nvoid pid_turn_left_by(float angle, float expected_angle) {\n    float error = 0.5;\n    float delay = 0.01; // 10 milliseconds\n    float integral = 0;\n    float prev_error = 0;\n    float derivation = 0;\n    float power = 0;\n    Drivetrain.setStopping(brake);\n    float cur_angle = Inertial12.rotation(degrees);\n    float final_angle = cur_angle - angle;\n    printf(\"Angle = %.2f, error = %.2f, final = %.2f\\n\", cur_angle, (cur_angle - expected_angle), final_angle);\n    error = Inertial12.rotation() - final_angle;\n    while(error > 0.2) {\n      integral += error * delay;\n      derivation = (error - prev_error) / delay;\n      power = kp * error + ki * integral + kd * derivation;\n      if (power < 1.5) {\n        power = 1.5;\n      }\n      RightDriveSmart.spin(forward, power, volt);\n      LeftDriveSmart.spin(reverse, power, volt);\n      wait(delay,seconds);\n      error = Inertial12.rotation() - final_angle;\n    }\n    Drivetrain.stop();\n    printf(\"stopped angle = %.2f\\n\", Inertial12.rotation());\n}\n\nvoid pid_turn_left_to(float angle) {\n    float error = 0.5;\n    float delay = 0.01; // 10 milliseconds\n    float integral = 0;\n    float prev_error = 0;\n    float derivation = 0;\n    float power = 0;\n    Drivetrain.setStopping(brake);\n    float cur_angle = Inertial12.rotation(degrees);\n    float final_angle = angle;\n    printf(\"Angle = %.2f, final = %.2f\\n\", cur_angle, final_angle);\n    error = Inertial12.rotation() - final_angle;\n    while(error > 0.2) {\n      integral += error * delay;\n      derivation = (error - prev_error) / delay;\n      power = kp * error + ki * integral + kd * derivation;\n      if (power < 1.5) {\n        power = 1.5;\n      }\n      RightDriveSmart.spin(forward, power, volt);\n      LeftDriveSmart.spin(reverse, power, volt);\n      wait(delay,seconds);\n      error = Inertial12.rotation() - final_angle;\n    }\n    Drivetrain.stop();\n    printf(\"stopped angle = %.2f\\n\", Inertial12.rotation());\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  rollersDirection = 0.0;\n  mobileGoalIntake.spinToPosition(0.0, degrees, true);\n  Inertial12.calibrate();\n  wait(0.5, seconds);\n  printf(\"Start done\\n\");\n  return 0;\n}\n\n// \"when Controller1 ButtonL2 pressed\" hat block\nvoid onevent_Controller1ButtonL2_pressed_0() {\n  if (rollersDirection == -1.0) {\n    rollers.stop();\n    rollersDirection = 0.0;\n  }\n  else {\n    rollers.setVelocity(90.0, percent);\n    rollers.spin(reverse);\n    rollersDirection = -1.0;\n  }\n}\n\n// \"when Controller1 ButtonR1 pressed\" hat block\nvoid onevent_Controller1ButtonR1_pressed_0() {\n  if (lifted) {\n    mobileGoalIntake.setVelocity(25.0, percent);\n  }\n  else {\n    lifted = true;\n    mobileGoalIntake.setVelocity(25.0, percent);\n    mobileGoalIntake.spinFor(forward, 135.0, degrees, true);\n  }\n}\n\n// \"when Controller1 ButtonR2 pressed\" hat block\nvoid onevent_Controller1ButtonR2_pressed_0() {\n  lifted = false;\n  mobileGoalIntake.setVelocity(50.0, percent);\n  while (Controller1.ButtonR2.pressing()) {\n    mobileGoalIntake.spin(reverse);\n  wait(5, msec);\n  }\n  mobileGoalIntake.stop();\n}\n\n// \"when Controller1 ButtonL1 pressed\" hat block\nvoid onevent_Controller1ButtonL1_pressed_0() {\n  if (rollersDirection == 1.0) {\n    rollers.stop();\n    rollersDirection = 0.0;\n  }\n  else {\n    rollers.setVelocity(90.0, percent);\n    rollers.spin(forward);\n    rollersDirection = 1.0;\n  }\n}\nfloat x = 100;\n// \"when Controller1 ButtonY pressed\" hat block\nvoid onevent_Controller1ButtonY_pressed_0() {\n  x = Drivetrain.velocity(percent);\n  Drivetrain.setDriveVelocity(30, percent);\n\n}\n\n// \"when Controller1 ButtonA pressed\" hat block\nvoid onevent_Controller1ButtonA_pressed_0() {\n  Drivetrain.setDriveVelocity(x, percent);\n}\n \n// \"when Controller1 ButtonDown pressed\" hat block\nvoid onevent_Controller1ButtonDown_pressed_0() {\n  mobileGoalIntake.setVelocity(50.0, percent);\n  mobileGoalIntake.spinFor(reverse, 30.0, degrees, true);\n}\n\n// \"when Controller1 ButtonUp pressed\" hat block\nvoid onevent_Controller1ButtonUp_pressed_0() {\n  mobileGoalIntake.setVelocity(50.0, percent);\n  mobileGoalIntake.spinFor(forward, 30.0, degrees, true);\n}\n\n// \"when Controller1 ButtonB pressed\" hat block\nvoid onevent_Controller1ButtonB_pressed_0() {\n  mobileGoalIntake.setVelocity(50.0, percent);\n  mobileGoalIntake.spinFor(reverse, 10.0, degrees, true);\n  \n}\n\n// \"when Controller1 ButtonX pressed\" hat block\nvoid onevent_Controller1ButtonX_pressed_0() {\n  float start_time = 0;\n  float end_time = 0;\n  float cur_angle = 0;\n  printf(\"**********Right turn test*************\\n\");\n  for (int i = 1; i <= 18; ++i) {\n    start_time = Brain.Timer.time(seconds);\n    pid_turn_right_by(i * 10, cur_angle);\n    cur_angle += i * 10;\n    end_time = Brain.Timer.time(seconds);\n    wait(2, seconds);\n    printf(\"Turn %d, time %.2f\\n\", i * 10, (end_time - start_time));\n  }\n  printf(\"**********Left turn test*************\\n\");\n  for (int i = 1; i <= 18; ++i) {\n    start_time = Brain.Timer.time(seconds);\n    pid_turn_left_by(i * 10, cur_angle);\n    cur_angle -= i * 10;\n    end_time = Brain.Timer.time(seconds);\n    wait(2, seconds);\n    printf(\"Turn %d, time %.2f\\n\", i * 10, (end_time - start_time));\n  }\n  //mobileGoalIntake.setVelocity(50.0, percent);\n  //mobileGoalIntake.spinFor(forward, 10.0, degrees, true);\n}\n\n// \"when autonomous\" hat block\nint onauton_autonomous_0() {\n  float current_angle = 0;\n  float roller_up_by = 125;\n  float roller_down_by = 100;\n  // Assume starting from red platform side\n  // Wait for IMU to calibrate\n  wait(1, seconds);\n  // Pull hood down\n  rollers.spinFor(forward, 100.0, degrees, true);\n  // Setup all the sppeds\n  Drivetrain.setDriveVelocity(45.0, percent);\n  Drivetrain.setTurnVelocity(20.0, percent);\n  mobileGoalIntake.setVelocity(30.0, percent);\n  rollers.setVelocity(50.0, percent);\n  // Let's start\n  Drivetrain.driveFor(forward, 10, inches, true);\n  current_angle += 117;\n  pid_turn_right_to(current_angle);\n  // Getting ready to pickup blue on red platform\n  mobileGoalIntake.spinFor(reverse, 295.0, degrees, true);\n  Drivetrain.driveFor(forward, 13.25, inches, true);\n  // Pickup goal\n  mobileGoalIntake.spinFor(forward, roller_up_by, degrees, true);\n  // Setup to push side yellow goal\n  Drivetrain.driveFor(reverse, 6.25, inches, true);\n  current_angle += 75;\n  pid_turn_right_to(current_angle);\n  // Push side yellow goal to other side near platform - 20 points\n  Drivetrain.driveFor(reverse, 70, inches, true);\n  // Turn right to put blue next to yellow away from platform\n  current_angle += 133;\n  pid_turn_right_to(current_angle);\n  Drivetrain.driveFor(forward, 20, inches, true);\n  // Drop blue goal - +20 points\n  mobileGoalIntake.spinFor(reverse, roller_down_by, degrees, true);\n  // Get clear of the goal\n  Drivetrain.driveFor(reverse, 11,inches, true);\n  // The blue goal can come in the way of picking red. So, just turn enough to push blue a bit away\n  current_angle -= 29.5;\n  pid_turn_left_to(current_angle);\n  // Push blue goal further in\n  //was 14.5c\n  // Setup to pickup red goal\n  //was 4\n  pid_turn_left_to(current_angle);\n  // Go a bit more than necessary as sometimes it is not enough\n  // Potentially, we can hit the wall but should be fine\n  Drivetrain.driveFor(forward, 15, inches, true);\n  // Pick up red goal\n  mobileGoalIntake.spinFor(forward, roller_up_by-15, degrees, true);\n  // Need to do two turn movement to go near central yellow goal without touching rings\n  Drivetrain.driveFor(reverse, 24.5, inches, true);\n  pid_turn_left_to(current_angle);\n  current_angle += 20;\n  pid_turn_right_to(current_angle);\n  // Now, ready to push center yellow goal\n  Drivetrain.driveFor(reverse, 78, inches, true); //reverse=down :)\n  // Setup to drop red gloal next to yellow\n  // Yellow in home +20 points (60 total)\n  current_angle += 200;\n  pid_turn_right_to(current_angle);\n  Drivetrain.driveFor(reverse, 6, inches, true);\n  current_angle += 20;\n  pid_turn_right_to(current_angle);\n  // Drop the goal\n  mobileGoalIntake.spinFor(reverse, roller_down_by+5, degrees, true);\n  // Go clear of goal\n  Drivetrain.driveFor(reverse, 10, inches, true);\n  // Setup to pickup blue goal\n  current_angle -= 40;\n  pid_turn_left_to(current_angle);\n  Drivetrain.driveFor(forward, 28, inches, true);\n  mobileGoalIntake.spinFor(forward, roller_up_by, degrees, true);\n  current_angle += 28;\n  pid_turn_right_to(current_angle);\n  Drivetrain.driveFor(reverse, 1550, mm);\n  current_angle -= 70;\n  pid_turn_left_to(current_angle);\n  Drivetrain.driveFor(forward, 400, mm);\n  current_angle -= 15;\n  pid_turn_left_to(current_angle);\n  Drivetrain.driveFor(forward, 200, mm);\n  mobileGoalIntake.spinFor(reverse, roller_down_by, degrees, true);\n  Drivetrain.driveFor(reverse, 100, mm);\n  return 0;\n}\n\nvoid VEXcode_driver_task() {\n  // Start the driver control tasks....\n\n\n  // Calibrate the Drivetrain Gyro\n  Inertial12.calibrate();\n\ntask rc_auto_loop_task_Controller1(rc_auto_loop_function_Controller1);\n  while(Competition.isDriverControl() && Competition.isEnabled()) {this_thread::sleep_for(10);}\n\n  return;\n}\n\nvoid VEXcode_auton_task() {\n  // Start the auton control tasks....\n  vex::task auto0(onauton_autonomous_0);\n  while(Competition.isAutonomous() && Competition.isEnabled()) {this_thread::sleep_for(10);}\n  auto0.stop();\n  return;\n}\n\n\n\nint main() {\n  vex::competition::bStopTasksBetweenModes = false;\n  Competition.autonomous(VEXcode_auton_task);\n  Competition.drivercontrol(VEXcode_driver_task);\n\n  // register event handlers\n  Controller1.ButtonL2.pressed(onevent_Controller1ButtonL2_pressed_0);\n  Controller1.ButtonR1.pressed(onevent_Controller1ButtonR1_pressed_0);\n  Controller1.ButtonR2.pressed(onevent_Controller1ButtonR2_pressed_0);\n  Controller1.ButtonL1.pressed(onevent_Controller1ButtonL1_pressed_0);\n  Controller1.ButtonDown.pressed(onevent_Controller1ButtonDown_pressed_0);\n  Controller1.ButtonUp.pressed(onevent_Controller1ButtonUp_pressed_0);\n  Controller1.ButtonB.pressed(onevent_Controller1ButtonB_pressed_0);\n  Controller1.ButtonX.pressed(onevent_Controller1ButtonX_pressed_0);\n  Controller1.ButtonY.pressed(onevent_Controller1ButtonY_pressed_0);\n  Controller1.ButtonA.pressed(onevent_Controller1ButtonA_pressed_0);\n\n  wait(15, msec);\n  // post event registration\n\n  // set default print color to black\n  printf(\"\\033[30m\");\n\n  // wait for rotation sensor to fully initialize\n  wait(30, msec);\n\n  whenStarted1();\n}\n\n\n","textLanguage":"cpp","rconfig":[{"port":[14,18,17,19,0],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[15,16],"name":"mobileGoalIntake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio36_1","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[20],"name":"rollers","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"split","id":"primary"},"triportSourcePort":22},{"port":[12],"name":"Inertial12","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20211210.18.00.00","appVersion":"2.3.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}